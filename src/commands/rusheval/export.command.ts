import { Context, Options, SlashCommandContext, Subcommand, BooleanOption } from "necord";
import { Model } from "mongoose";
import { InjectModel } from "@nestjs/mongoose";
import { RushEvalCommandDecorator } from "./rusheval.command";
import { Team } from "src/schema/team.schema";
import puppeteer from "puppeteer";
import { EmbedBuilder } from "discord.js";
import { unlink } from "fs";
import { ConsoleLogger } from "@nestjs/common";

class ForceDto {
  @BooleanOption({
    name: 'force',
    description: "Export feedback regardless there's teams without feedbacks",
    required: false
  })
  force: boolean;
}

interface EvaluatorTeamsAggregation {
  evaluator: string,
  teams: {
    name: string,
    timeslot: string,
    feedbackAt: Date,
  }[]
}

@RushEvalCommandDecorator()
export class RushEvalExportFeedbackCommand {
  private readonly logger = new ConsoleLogger("RushEvalExportFeedbackCommand", {timestamp: true});
  constructor(
    @InjectModel(Team.name) private readonly teamModel: Model<Team>,
  ) { }

  @Subcommand({
    name: "export",
    description: "Export feedbacks",
  })
  public async onExecute(@Context() [interaction]: SlashCommandContext, @Options() { force }: ForceDto) {
    await interaction.deferReply({ephemeral: true});
    this.logger.log(`Export command called by ${interaction.user.username}${force ? " with force" : ""}`);
    if (force !== true) {
      const teamNoFeedback: EvaluatorTeamsAggregation[] = await this.teamModel.aggregate([
        { $match: { feedback: undefined } },
        { $group: { _id: "$evaluator.intraName", teams: { $push: { name: "$name", timeslot: "$timeslot.timeslot", feedbackAt: "$feedbackAt" } } } },
        { $project: { evaluator: "$_id", teams: "$teams", _id: 0 } },
      ]);

      if (teamNoFeedback.length !== 0) {
        const embed = new EmbedBuilder()
          .setTitle("Teams without feedback")
          .setFields(teamNoFeedback.map(t => ({
            name: t.evaluator ?? "Unknown",
            value: t.teams.map(t => `${t.name} (${t.timeslot})`).join("\n"),
          })))
          .setColor("#00FFFF")
          ;
        this.logger.log(`Teams without feedback: ${teamNoFeedback.map(t => t.evaluator).join(", ")}`);
        return interaction.editReply({content: `Below teams don't have feedbacks:`, embeds: [embed]});
      }
    }
    const teams = await this.teamModel.find().exec();
    const outfile = "feedbacks.pdf";
    const getReplyContent = () => {
      if (force !== true) {
        return `Exported ${teams.length} teams with feedbacks`;
      } else {
        const teamWithFeedbackCount = teams.reduce((acc, e) => acc + Number(e.feedbackAt !== undefined), 0);
        return `Exported ${teamWithFeedbackCount}/${teams.length} teams with feedbacks`;
      }
    };

    return this.exportFeedbacks(outfile, teams).then(() => {
      this.logger.log(getReplyContent());
      return interaction.editReply({content: getReplyContent(), files: [outfile]});
    }).catch((err) => {
      this.logger.error(err);
      console.error(err);
      return interaction.editReply({content: "Failed to export feedbacks"});
    }).finally(() => unlink(outfile, () => {}));
  }

  private async exportFeedbacks(filename: string, teams: Team[]) {
    const timeout = 3 * 60 * 1000;

    this.logger.log(`Lauching headless browser`);
    const browser = await puppeteer.launch({headless: "new", timeout: timeout});

    this.logger.log(`Opening new page`);
    const page = await browser.newPage();

    this.logger.log(`Setting content`);
    teams.sort((a, b) => a.timeslot?.timeslot.localeCompare(b.timeslot?.timeslot));
    await page.setContent(`
<!DOCTYPE html>
<html lang="en">
<head>
  <title>2024 Jan rush01 Internal Feedbacks</title>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <style>
    body {
      background-color: #222222;
      color: #FFFFFF;
      text-align: center;
      font-family: Arial, Helvetica, sans-serif;
      font-size: 2.2vw;
      margin: 2vw;
    }

    .nav {
      text-decoration: none;
      color: #AAFFFF;
      background-color: #AAAAAAA;
    }

    h3 {
      margin-bottom: 0;
    }

    .essay {
      font-size: 2vw;
      text-align: left;
      font-family: Calibri;
    }

  </style>
</head>
<body>
  <h1>2024 Jan rush01 Internal Feedbacks</h1>
  <p>This document is generated by THILA Bot at ${new Date().toLocaleString()}</p>
  ${teams.map(team => `<a class="nav" href="#${team.name}">${team.name}</a>`).join("\n<br>\n<br>\n")}
${teams.map(team => `
  <div style="page-break-after:always;"></div>
  <h2 id="${team.name}">${team.name}</h2>
  <hr style="border: 2px solid; border-radius: 4px;">
  <h3>${team.evaluator?.intraName ?? ''}: ${team.timeslot?.timeslot ?? ''}</h3>
  <h3>Members Overview</h3>
  <hr>
  <p class="essay">${team.feedback?.get(team.name).replaceAll("\n", "<br>\n") ?? ''}</p>
  <h3>Notes</h3>
  <hr>
  <p class="essay">${team.feedback?.get("notes").replaceAll("\n", "<br>\n") ?? ''}</p>
`).join("")}
</body>
</html>
`);
    this.logger.log(`Exporting to ${filename}`);
    await page.pdf({path: filename, printBackground: true, format: "A4", timeout: timeout});
    browser.close().catch((err) => {this.logger.error(err, "Close Browser");});
  }
}
